function init() {
      generateRobotsTxt();
      attachRuleListeners();
    }

    function loadTemplate(template) {
      const container = document.getElementById('rulesContainer');
      container.innerHTML = '';

      const templates = {
        'allow-all': [
          { userAgent: '*', directive: 'Allow', path: '/' }
        ],
        'block-all': [
          { userAgent: '*', directive: 'Disallow', path: '/' }
        ],
        'wordpress': [
          { userAgent: '*', directive: 'Disallow', path: '/wp-admin/' },
          { userAgent: '*', directive: 'Disallow', path: '/wp-includes/' },
          { userAgent: '*', directive: 'Disallow', path: '/wp-content/plugins/' },
          { userAgent: '*', directive: 'Disallow', path: '/wp-content/themes/' },
          { userAgent: '*', directive: 'Allow', path: '/wp-content/uploads/' }
        ],
        'ecommerce': [
          { userAgent: '*', directive: 'Disallow', path: '/cart/' },
          { userAgent: '*', directive: 'Disallow', path: '/checkout/' },
          { userAgent: '*', directive: 'Disallow', path: '/account/' },
          { userAgent: '*', directive: 'Disallow', path: '/admin/' },
          { userAgent: '*', directive: 'Allow', path: '/products/' }
        ]
      };

      const rules = templates[template];
      rules.forEach((rule, index) => {
        const ruleHtml = createRuleElement(index + 1, rule);
        container.insertAdjacentHTML('beforeend', ruleHtml);
      });

      attachRuleListeners();
      generateRobotsTxt();
      showToast(`${template.replace('-', ' ')} template loaded!`);
    }

    function createRuleElement(number, rule = { userAgent: '*', directive: 'Disallow', path: '/' }) {
      return `
        <div class="rule-item">
          <div class="rule-header">
            <span class="rule-title">Rule ${number}</span>
            <button class="delete-rule-btn" onclick="deleteRule(this)">Delete</button>
          </div>
          <label class="input-label">User-agent</label>
          <input type="text" class="input-field user-agent" value="${rule.userAgent}" placeholder="* for all bots">
          <label class="input-label">Directive</label>
          <select class="input-field directive">
            <option value="Disallow" ${rule.directive === 'Disallow' ? 'selected' : ''}>Disallow</option>
            <option value="Allow" ${rule.directive === 'Allow' ? 'selected' : ''}>Allow</option>
          </select>
          <label class="input-label">Path</label>
          <input type="text" class="input-field path" value="${rule.path}" placeholder="/admin/">
        </div>
      `;
    }

    function addRule() {
      const container = document.getElementById('rulesContainer');
      const ruleCount = container.children.length + 1;
      const ruleHtml = createRuleElement(ruleCount);
      container.insertAdjacentHTML('beforeend', ruleHtml);
      attachRuleListeners();
      generateRobotsTxt();
    }

    function deleteRule(btn) {
      const container = document.getElementById('rulesContainer');
      if (container.children.length > 1) {
        btn.closest('.rule-item').remove();
        updateRuleNumbers();
        generateRobotsTxt();
      } else {
        showToast('Must have at least one rule', 'error');
      }
    }

    function updateRuleNumbers() {
      const rules = document.querySelectorAll('.rule-item');
      rules.forEach((rule, index) => {
        rule.querySelector('.rule-title').textContent = `Rule ${index + 1}`;
      });
    }

    function attachRuleListeners() {
      document.querySelectorAll('.user-agent, .directive, .path').forEach(input => {
        input.removeEventListener('input', generateRobotsTxt);
        input.removeEventListener('change', generateRobotsTxt);
        input.addEventListener('input', generateRobotsTxt);
        input.addEventListener('change', generateRobotsTxt);
      });
    }

    function generateRobotsTxt() {
      const rules = document.querySelectorAll('.rule-item');
      const sitemapUrl = document.getElementById('sitemapUrl').value.trim();
      
      let robotsTxt = '# Generated by Robots.txt Generator\n';
      robotsTxt += '# ' + new Date().toISOString().split('T')[0] + '\n\n';

      // Group rules by user-agent
      const grouped = {};
      rules.forEach(rule => {
        const userAgent = rule.querySelector('.user-agent').value.trim() || '*';
        const directive = rule.querySelector('.directive').value;
        const path = rule.querySelector('.path').value.trim() || '/';

        if (!grouped[userAgent]) {
          grouped[userAgent] = [];
        }
        grouped[userAgent].push({ directive, path });
      });

      // Generate output
      Object.entries(grouped).forEach(([userAgent, directives]) => {
        robotsTxt += `User-agent: ${userAgent}\n`;
        directives.forEach(d => {
          robotsTxt += `${d.directive}: ${d.path}\n`;
        });
        robotsTxt += '\n';
      });

      // Add sitemap
      if (sitemapUrl) {
        robotsTxt += `Sitemap: ${sitemapUrl}\n`;
      }

      document.getElementById('robotsOutput').textContent = robotsTxt;
    }

    function copyRobotsTxt() {
      const output = document.getElementById('robotsOutput').textContent;
      navigator.clipboard.writeText(output).then(() => {
        showToast('Copied to clipboard!');
      });
    }

    function downloadRobotsTxt() {
      const output = document.getElementById('robotsOutput').textContent;
      const blob = new Blob([output], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'robots.txt';
      a.click();
      URL.revokeObjectURL(url);
      showToast('Downloaded robots.txt!');
    }

    function showToast(message, type = 'success') {
      const existingToast = document.querySelector('.toast');
      if (existingToast) existingToast.remove();
      
      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.style.background = type === 'error' ? '#ef4444' : '#10b981';
      toast.textContent = message;
      document.body.appendChild(toast);
      
      setTimeout(() => toast.remove(), 3000);
    }

    init();
